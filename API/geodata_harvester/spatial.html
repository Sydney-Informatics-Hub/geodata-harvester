<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>geodata_harvester.spatial API documentation</title>
<meta name="description" content="Utility functions for for spatial processing â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>geodata_harvester.spatial</code></h1>
</header>
<section id="section-intro">
<p>Utility functions for for spatial processing.</p>
<p>&ndash;Function List, in order of appearence&ndash;</p>
<p>_points_in_circle(internal): Return all points whose indices are within a given
circle.
_coreg_buffer(internal): Queries values of a raster around a point buffer
region.
raster_buffer: Given a longitude,latitude point, a raster file, and a buffer
region, find the values of all points in circular buffer.
_get_features(internal): Parse features from GeoDataFrame format to Rasterio
format
_coreg_polygon(internal): Crops a raster to a polygon shape.
raster_polygon_buffer: Given list of longitudes and latitudes defining a
polygon, crop raster file, return the values of all points in the polygon.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">#!/bin/python
&#34;&#34;&#34;

Utility functions for for spatial processing.

--Function List, in order of appearence--

_points_in_circle(internal): Return all points whose indices are within a given
    circle.
_coreg_buffer(internal): Queries values of a raster around a point buffer
    region.
raster_buffer: Given a longitude,latitude point, a raster file, and a buffer
    region, find the values of all points in circular buffer.
_get_features(internal): Parse features from GeoDataFrame format to Rasterio
    format
_coreg_polygon(internal): Crops a raster to a polygon shape.
raster_polygon_buffer: Given list of longitudes and latitudes defining a
    polygon, crop raster file, return the values of all points in the polygon.
&#34;&#34;&#34;

from glob import glob
import os
import json

import rasterio
from rasterio.mask import mask
from rasterio.warp import calculate_default_transform, reproject, Resampling
from rasterio.plot import show

import numpy as np
import pandas as pd
import geopandas as gpd

from pyproj import CRS
from pathlib import Path

import matplotlib.pyplot as plt
from matplotlib.ticker import FormatStrFormatter

from numba import jit

from geodata_harvester import utils

from shapely.geometry import Polygon
from fiona.crs import from_epsg
import json


@jit(nopython=True)
def _points_in_circle(i0, j0, r, xlen, ylen):
    &#34;&#34;&#34;
    A generator to return all points whose indices are within a given circle.
    http://stackoverflow.com/a/2774284
    Warning: If a point is near the the edges of the raster it will not loop
    around to the other side of the raster!
    We yield indexs of points, so this function may be sped up without the
    need for passing data matiricies back and forth.

    INPUTS
    i0: x index column locator centre point
    j0: y index row locator centre point
    r: radius of circle in pixel/index units
    xlen: no. columns of data array.
    ylen: no. rows of data array.

    RETURNS
    generator of tuple containing x-y array index values.

    &#34;&#34;&#34;
    def intceil(x):
        return int(np.ceil(x))

    for i in range(intceil(i0-r), intceil(i0+r)):
        ri = np.sqrt(r**2-(i-i0)**2)
        for j in range(intceil(j0-ri), intceil(j0+ri)):
            if (i &gt;= 0 and i &lt; xlen) and (j &gt;= 0 and j &lt; ylen):
                # yield arr[i][j]
                yield((i, j))


def _points_in_polygon(i0, j0, polygon):
    # For each point in arr, check if it is inside polygon.
    # Not implemented, or required. Use _coreg_polygon
    pass


def _coreg_buffer(i0, j0, data, region):
    &#34;&#34;&#34;
    Coregisters a point with a buffer region of a raster.

    INPUTS
    i0: column-index of point of interest
    j0: row-index of point of interest
    data: two-dimensional numpy array (raster)
    region: integer radius, same units as data resolution.

    RETURNS
    pts: all values from array within region
    &#34;&#34;&#34;

    if (type(region) == float) or (type(region) == int):
        pts_iterator = _points_in_circle(
                            i0, j0, region, len(data[:, 0]), len(data[0, :]))

    else:
        print(&#34;This method only uses circular buffers defined by a radius. \
            For buffers defined by a polygon use _coreg_polygon. \
            &#34;)

    # Convert list of returned tuples to indexes readable by the data array.
    pts = tuple(zip(*list(pts_iterator)))

    return data[pts]


def raster_buffer(long, lat, raster, buffer):
    &#34;&#34;&#34;
    given a longitude,latitude point, a raster file, and a buffer region,
        return the value values of all points in circular buffer.

    INPUTS:
    long: longitude point of interest
    lat: latitude point of interest
    raster: file path/name (as string)
    buffer: integer, raster array pixel units to return values for

    RETURNS
    values: list of raster array values around point of interest.
    &#34;&#34;&#34;
    print(&#34;Opening:&#34;, raster)
    # raster = gdal.Open(raster)
    raster = rasterio.open(raster)

    # Get the transformation crs data
    # gt = raster.GetGeoTransform()
    gt  = raster.transform

    # Interogate the tiff file as an array
    # This will only be the first band, usally multiband has same index.
    # arr = raster.GetRasterBand(1).ReadAsArray()
    arr = raster.read(1)

    # FIXME Check the number of bands and print a warning if more than 1

    # Shape of raster
    print(&#34;Raster pixel size:&#34;, np.shape(arr))

    # get row/column index of point
    point = utils._get_coords_at_point(gt, long, lat)

    # get values of data array at the buffer-index locations
    values = _coreg_buffer(point[0], point[1], arr, buffer)

    return(values)


def _get_features(gdf):
    &#34;&#34;&#34;
    Function to parse features from GeoDataFrame in such a manner that
        rasterio wants them

    gdf: geodataframe of a geometry polygon.
    &#34;&#34;&#34;
    return [json.loads(gdf.to_json())[&#39;features&#39;][0][&#39;geometry&#39;]]


def _coreg_polygon(data, polygon):
    &#34;&#34;&#34;
    Crops a raster to a polygon shape.

    INPUTS
    data: gdal raster object.
    polygon: Shapely Polygon defining area to crop.

    RETURNS
    out_img: Returns array of values inside the polygon.
    &#34;&#34;&#34;
    geo = gpd.GeoDataFrame({&#39;geometry&#39;: polygon}, index=[0], crs=from_epsg(4326))
    geo = geo.to_crs(crs=data.crs.data)
    coords = _get_features(geo)
    out_img, _ = mask(data, shapes=coords, crop=True)

    return(out_img)


def raster_polygon_buffer(lngs, lats, raster):
    &#34;&#34;&#34;
    Given a list of longitudes and latitudes that define a polygone, crop a
        raster file, and return the values of all points in the polygon.

    INPUTS:
    lngs: list of longitudes
    lats: list of latitudes
    raster: file path/name (as string) of raster

    RETURNS
    values: list of raster array values inside polygon.
    &#34;&#34;&#34;
    if (len(lngs) != len(lats)):
        raise ValueError(&#34;Longitude and Latitude list should be equal in length\
            representing pairs of points defining a polygon.&#34;)

    print(&#34;Opening:&#34;, raster)
    # raster = gdal.Open(raster)
    raster = rasterio.open(raster)

    # get row/column index of point
    polygon = Polygon(list(zip(lngs, lats)))

    # get values of data array at the buffer-index locations
    values = _coreg_polygon(raster, polygon)

    return(values)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="geodata_harvester.spatial.raster_buffer"><code class="name flex">
<span>def <span class="ident">raster_buffer</span></span>(<span>long, lat, raster, buffer)</span>
</code></dt>
<dd>
<div class="desc"><p>given a longitude,latitude point, a raster file, and a buffer region,
return the value values of all points in circular buffer.</p>
<p>INPUTS:
long: longitude point of interest
lat: latitude point of interest
raster: file path/name (as string)
buffer: integer, raster array pixel units to return values for</p>
<p>RETURNS
values: list of raster array values around point of interest.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def raster_buffer(long, lat, raster, buffer):
    &#34;&#34;&#34;
    given a longitude,latitude point, a raster file, and a buffer region,
        return the value values of all points in circular buffer.

    INPUTS:
    long: longitude point of interest
    lat: latitude point of interest
    raster: file path/name (as string)
    buffer: integer, raster array pixel units to return values for

    RETURNS
    values: list of raster array values around point of interest.
    &#34;&#34;&#34;
    print(&#34;Opening:&#34;, raster)
    # raster = gdal.Open(raster)
    raster = rasterio.open(raster)

    # Get the transformation crs data
    # gt = raster.GetGeoTransform()
    gt  = raster.transform

    # Interogate the tiff file as an array
    # This will only be the first band, usally multiband has same index.
    # arr = raster.GetRasterBand(1).ReadAsArray()
    arr = raster.read(1)

    # FIXME Check the number of bands and print a warning if more than 1

    # Shape of raster
    print(&#34;Raster pixel size:&#34;, np.shape(arr))

    # get row/column index of point
    point = utils._get_coords_at_point(gt, long, lat)

    # get values of data array at the buffer-index locations
    values = _coreg_buffer(point[0], point[1], arr, buffer)

    return(values)</code></pre>
</details>
</dd>
<dt id="geodata_harvester.spatial.raster_polygon_buffer"><code class="name flex">
<span>def <span class="ident">raster_polygon_buffer</span></span>(<span>lngs, lats, raster)</span>
</code></dt>
<dd>
<div class="desc"><p>Given a list of longitudes and latitudes that define a polygone, crop a
raster file, and return the values of all points in the polygon.</p>
<p>INPUTS:
lngs: list of longitudes
lats: list of latitudes
raster: file path/name (as string) of raster</p>
<p>RETURNS
values: list of raster array values inside polygon.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def raster_polygon_buffer(lngs, lats, raster):
    &#34;&#34;&#34;
    Given a list of longitudes and latitudes that define a polygone, crop a
        raster file, and return the values of all points in the polygon.

    INPUTS:
    lngs: list of longitudes
    lats: list of latitudes
    raster: file path/name (as string) of raster

    RETURNS
    values: list of raster array values inside polygon.
    &#34;&#34;&#34;
    if (len(lngs) != len(lats)):
        raise ValueError(&#34;Longitude and Latitude list should be equal in length\
            representing pairs of points defining a polygon.&#34;)

    print(&#34;Opening:&#34;, raster)
    # raster = gdal.Open(raster)
    raster = rasterio.open(raster)

    # get row/column index of point
    polygon = Polygon(list(zip(lngs, lats)))

    # get values of data array at the buffer-index locations
    values = _coreg_polygon(raster, polygon)

    return(values)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="geodata_harvester" href="index.html">geodata_harvester</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="geodata_harvester.spatial.raster_buffer" href="#geodata_harvester.spatial.raster_buffer">raster_buffer</a></code></li>
<li><code><a title="geodata_harvester.spatial.raster_polygon_buffer" href="#geodata_harvester.spatial.raster_polygon_buffer">raster_polygon_buffer</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>