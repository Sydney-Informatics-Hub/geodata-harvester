<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>geodata_harvester.temporal API documentation</title>
<meta name="description" content="Utility functions for temporal processing â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>geodata_harvester.temporal</code></h1>
</header>
<section id="section-intro">
<p>Utility functions for temporal processing.</p>
<p>&ndash;Main function list&ndash;</p>
<p>combine_rasters_temporal: Concatenates files by time returns xarray.
aggregate_temporal: Aggregates xarrays by specified function and time period.
temporal_crop: Cuts an xarray object by start and end times.
aggregate_temporal: Make a data aggregation (mean, median, sum, etc) through time on an xarray.</p>
<p>&ndash;Helper function list&ndash;</p>
<p>get_date_after_last_underscore: Extract the date from the file name after the last underscore.
get_mask_array: Return mask of the data, e.g. for cloud-cover.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
Utility functions for temporal processing.

--Main function list--

combine_rasters_temporal: Concatenates files by time returns xarray.
aggregate_temporal: Aggregates xarrays by specified function and time period.
temporal_crop: Cuts an xarray object by start and end times.
aggregate_temporal: Make a data aggregation (mean, median, sum, etc) through time on an xarray.

--Helper function list--

get_date_after_last_underscore: Extract the date from the file name after the last underscore.
get_mask_array: Return mask of the data, e.g. for cloud-cover.
&#34;&#34;&#34;

import numpy as np
import pandas as pd
import rioxarray
import xarray as xr
import datetime


def combine_rasters_temporal(
    file_list, channel_name=&#34;band&#34;, attribute_name=&#34;long_name&#34;
):
    &#34;&#34;&#34;
    Combines multiple tif files into single xarray object. 
    Assumes additional channels contain sequential time step data. 
    If multiple files in file_list, files must be in temporal order and same data type.
    Also assumes files are of the same shape (x,y,t).

    Example:
    file_list = [&#39;../data/mvp_daily_rain_silo/daily_rain_2017_cropped.tif&#39;,
             &#39;../data/mvp_daily_rain_silo/daily_rain_2018_cropped.tif&#39;]

    xdr = combine_rasters_temporal(file_list, channel_name=&#39;band&#39;,attribute_name=&#39;long_name&#39;)

    Parameters
    ----------
    file_list : str or list of filename strings in date order to concatenate.
        Expected to be of the form &#34;x,y&#34; or &#34;x,y,z1&#34;
    channel_name : string of coordinate dimension to concatentate (band, time,
        etc). Check options with rioxarray.open_rasterio(&#39;filename&#39;).coords
    attribute_name : string name of rioxarray attribute holding a time/date
        label. Check with rioxarray.open_rasterio(&#39;filename&#39;).attrs

    Returns
    -------
    xdr : xarray object of x,y,time, with approriate metadata.

    &#34;&#34;&#34;
    #print(&#34;Concatenating&#34;, channel_name, &#34;and&#34;, attribute_name, &#34;over&#34;, file_list)
    # file_list = glob(os.path.join(data_dir, &#39;*.tif&#39;))

    if type(file_list) == str:
        file_list = [file_list]

    # Append all data/channels, collect metadata lists
    array_list = []
    attrs = ()
    first = True
    for x in file_list:
        xds = rioxarray.open_rasterio(x)

        if channel_name not in xds.coords:
            raise ValueError(
                channel_name + &#34; not a channel in the raster &#34; + x + &#34; Options are&#34;,
                [t for t in xds.coords],
            )
            return None

        if attribute_name not in xds.attrs:
            raise ValueError(
                attribute_name
                + &#34; not an attribute in the raster &#34;
                + x
                + &#34; Options are&#34;,
                [t for t in xds.attrs],
            )
            return None

        array_list.append(xds)
        #print(&#34;attrs&#34;, xds.attrs[attribute_name])
        try:
            attrs = attrs + xds.attrs[attribute_name]
        except:
            attrs = attrs + (xds.attrs[attribute_name],)
        if first == True:
            coords = xds[channel_name].values

            first = False
        else:
            coords = np.append(coords, xds[channel_name].values + coords[-1])

    xdr = xr.concat(array_list, channel_name)
    # print(agg,coords,attrs)
    # xdr = xdr.assign_attrs({attr: attrs})
    xdr = xdr.assign_coords({channel_name: np.array(pd.to_datetime(attrs))})
    xdr = xdr.rename({channel_name: &#34;time&#34;})
    del xdr.attrs[attribute_name]

    return xdr


def multiband_raster_to_xarray(file_list, date_list = None, mask_bandname = None):
    &#34;&#34;&#34;
    Converts a stack of multiband raster with different dates to an xarray object.
    
    Parameters
    ----------
    file_list : list of filename strings in date order to concatenate.
    date_list : list of dates in date order to concatenate. 
        If None provided, the dates will be extracted from the file names.
        This assumes that the date is given at the end of the file name after an underscore.
    &#34;&#34;&#34;
    # Extract the dates from the file names if no date list is provided
    if date_list is None:
        date_list = get_date_after_last_underscore(file_list)

    # Check if the lists have the same length
    assert len(file_list) == len(date_list), &#34;File list and date list must have the same length.&#34;
    
    # Create an empty list to store the DataArrays
    data_arrays = []

    for file, date in zip(file_list, date_list):
        # Read the raster file using rioxarray
        xds = rioxarray.open_rasterio(file)

        # Assign the time coordinate
        xds = xds.assign_coords({&#34;time&#34;: pd.to_datetime(date)})
        xds = xds.expand_dims(&#34;time&#34;)

        # Append the DataArray to the list
        data_arrays.append(xds)

    # Concatenate the DataArrays along the time dimension
    stacked_data = xr.concat(data_arrays, dim=&#34;time&#34;)

    return stacked_data


def temporal_crop(xdr, start_time, end_time):
    &#34;&#34;&#34;
    Cuts an xarray object by start and end times.

    Parameters
    ----------
    xdr : xarray object of x,y,time
    start_time : string time in &#39;yyyy-mm-dd&#39; format.
    end_time : string time in &#39;yyyy-mm-dd&#39; format.

    Returns
    -------
    xdr_crop : xarray object of x,y,time, with approriate metadata.
    &#34;&#34;&#34;

    xdr_crop = xdr.sel(time=slice(start_time, end_time))

    return(xdr_crop)


def aggregate_temporal(xdr,
    period=&#34;yearly&#34;, agg=[&#34;mean&#34;], outfile=&#34;temporal_agg&#34;, buffer = None, fill_nan = True):
    &#34;&#34;&#34;
    Make a data aggregation (mean, median, sum, etc) through time on an xarray.
    Expects xarray coordinates to be x, y, time. Saves every aggregation for
    every time period as its own tif file.

    Example:
    file_list = [&#39;../data/mvp_daily_rain_silo/daily_rain_2017_cropped.tif&#39;,
         &#39;../data/mvp_daily_rain_silo/daily_rain_2018_cropped.tif&#39;]

    xdr = combine_rasters_temporal(file_list, channel_name=&#39;band&#39;,attribute_name=&#39;long_name&#39;)

    outfname_list, agg_list = aggregate_temporal(
        xdr,period=100,agg=[&#39;mean&#39;,&#39;sum&#39;],outfile=&#39;temporal_agg&#39;)

    Parameters
    ----------
    xdr : xarray object of x,y,time
    period : string or int. Time period to perform aggregation,
        &#39;yearly&#39;, &#39;monthly&#39;, or number of periods to aggregate over.
    agg: list of strings. Choice of aggregation methods to apply of
        [&#39;mean&#39;,&#39;median&#39;,&#39;sum&#39;,&#39;perc95&#39;,&#39;perc5&#39;]
    outfile : string. Prefix of output file name.
    buffer: integer time period in same units as period to buffer into the future.
    fill_nan: boolean. If True (Default), will automatically try to find the value for missing data 
        from header and fills with nan before aggregating. If False, will not fill nan.

    Returns
    -------
    outfname_list : list of strings of output file names
    agg_list : list of strings of aggregation methods

    &#34;&#34;&#34;

    if fill_nan:
        # Define the possible attribute names for fill values
        nodata_names = [&#34;_FillValue&#34;, &#34;missing_value&#34;, &#34;nodata&#34;, &#34;nodatavalue&#34;]
        nodata_name_found = False
        for nodata_name in nodata_names:
            if nodata_name in xdr.attrs:
                xdr = xdr.where(xdr != xdr.attrs[nodata_name], np.nan)
                nodata_name_found = True
                break
        # Check for case-insensitive nodata names
        if not nodata_name_found:
            for key, value in xdr.attrs.items():
                if key.lower() in [attr.lower() for attr in nodata_names]:
                    xdr = xdr.where(xdr != value, np.nan)
                    nodata_name_found = True
                    break


    # Check the aggregation methods are okay
    agg_types = [&#34;mean&#34;, &#34;median&#34;, &#34;sum&#34;, &#34;perc95&#34;, &#34;perc5&#34;, &#34;max&#34;, &#34;min&#34;]
    aggcheck = [a for a in agg if a in agg_types]
    if aggcheck is None:
        raise ValueError(&#34;Invalid Aggregation type. Expected any of: %s&#34; % agg_types)
    #else:
        #print(&#34;Finding&#34;, aggcheck, &#34; out of possible&#34;, agg_types)
        #print(&#34;for&#34;, period, &#34; period.&#34;)

    # Group by the appropriate time period
    if period == &#34;yearly&#34;:
        xdr_groups = xdr.groupby(&#34;time.year&#34;)

        if buffer != None:
            xx = xdr_groups.apply(lambda x: x.isel(time=slice(0,buffer)))
            xdr_groups = xx.groupby(&#34;time.year&#34;)

    elif period == &#34;monthly&#34;:
        xdr_groups = xdr.groupby(&#34;time.month&#34;)

        if buffer != None:
            xx = xdr_groups.apply(lambda x: x.isel(time=slice(0,buffer)))
            xdr_groups = xx.groupby(&#34;time.month&#34;)

    elif type(period) == int:
        time_start = xdr.time.values[0].astype(&#39;datetime64[s]&#39;).tolist()
        time_end = xdr.time.values[-1].astype(&#39;datetime64[s]&#39;).tolist()
        bins = (time_end - time_start).days // period
        #bins = int(np.floor(len(xdr) / period)) # this only works if len(xdr) is in days
        if bins == 0:
            # If the period is smaller than the time step, use the time step as the period
            bins = 1
        xdr_groups = xdr.groupby_bins(&#34;time&#34;, bins)

        if buffer != None:
            xx = xdr_groups.apply(lambda x: x.isel(time=slice(0,buffer)))
            xdr_groups = xx.groupby_bins(&#34;time&#34;, period)


    else:
        raise ValueError(
            &#34;Invalid temporal period. Expected any of: &#39;yearly&#39;, &#39;monthly&#39;, or an integer period&#34;
        )

    aggdict = {}
    for agg_type in aggcheck:
        if agg_type == &#34;mean&#34;:
            aggdict[&#34;mean&#34;] = xdr_groups.mean()
        elif agg_type == &#34;median&#34;:
            aggdict[&#34;median&#34;] = xdr_groups.median()
        elif agg_type == &#34;sum&#34;:
            aggdict[&#34;sum&#34;] = xdr_groups.sum()
        elif agg_type == &#34;perc95&#34;:
            aggdict[&#34;perc95&#34;] = xdr_groups.quantile(q=0.95)
        elif agg_type == &#34;perc5&#34;:
            aggdict[&#34;perc5&#34;] = xdr_groups.quantile(q=0.05)
        elif agg_type == &#34;max&#34;:
            aggdict[&#34;max&#34;] = xdr_groups.max()
        elif agg_type == &#34;min&#34;:
            aggdict[&#34;min&#34;] = xdr_groups.min()


    # Keep track of the names of all files produced
    outfname_list = []
    agg_list = []

    # For all the different aggregation methods
    for a in aggcheck:
        # For each period of time in each of the groups, save it out!
        for p in aggdict[a]:

            # Each temporal grouping results in different group labels
            if period == &#34;yearly&#34;:
                label = str(p[&#34;year&#34;].values)
            elif period == &#34;monthly&#34;:
                label = str(p[&#34;month&#34;].values).zfill(2)
            elif type(period) == int:
                label = str(p[&#34;time_bins&#34;].values)[1:11]

            p.rio.to_raster(outfile + &#34;_&#34; + a + &#34;_&#34; + label + &#34;.tif&#34;)
            outfname_list.append(outfile + &#34;_&#34; + a + &#34;_&#34; + label + &#34;.tif&#34;)
            agg_list.append(a)

            print(a, &#34;of&#34;, label, &#34;saved in:&#34;, outfile + &#34;_&#34; + a + &#34;_&#34; + label + &#34;.tif&#34;)

    return outfname_list, agg_list


def get_date_after_last_underscore(file_list):
    &#34;&#34;&#34;
    Extract the date from the file name after the last underscore.

    Parameters
    ----------
    file_list : list of filename strings in date order to concatenate.

    Returns
    -------
    result : list of dates in date order to concatenate.
    &#34;&#34;&#34;
    result = []

    for filename in file_list:
        split_string = filename.rsplit(&#39;_&#39;, 1)  # Split the string from the right side, keeping only the last part

        # Check if the string was split
        if len(split_string) &gt; 1:
            last_part = split_string[-1]  # Get the part after the last &#34;_&#34;
        else:
            last_part = filename  # If the string didn&#39;t have any &#34;_&#34;, return the original string

        # Remove the file format ending
        last_part = last_part.rsplit(&#39;.&#39;, 1)[0]

        # test if the last part is a date
        try:
            datetime.datetime.strptime(last_part, &#39;%Y-%m-%d&#39;)
        except ValueError:
            print(&#34;The last part of the filename is not a date: &#34;, last_part)
            raise ValueError

        result.append(last_part)

    return result


def get_mask_array(xdr, mask_band = None, verbose = True):
    &#34;&#34;&#34;
    Return mask of the data, e.g. for cloud-cover.
    The mask values will be set to True if the mask band is not 0, and False otherwise.
    If no mask band is provided, a mask band will be searched for in the xarray attribute metadata.

    Parameters
    ----------
    xdr : xarray
        xarray dataset to mask
    mask_band : str or int, optional   
        Name or index of the band to use as a mask. 
        If not provided, a mask abd will be searched for in the xarray attribute metadata.

    Returns
    -------
    mask: array, bool
    &#34;&#34;&#34;
    if mask_band is not None:
        if isinstance(mask_band, int):
            if verbose: print(f&#34;Masking values with Nan where mask band {mask_band} is not 0&#34;)
        elif isinstance(mask_band, str):
            if verbose: print(f&#34;Masking values with Nan where mask band {mask_band} is not 0&#34;)
            mask_band = [i for i, s in enumerate(xdr.attrs[&#39;long_name&#39;]) if s == mask_band]
            mask_band = mask_band[0] + 1
        else:
            if verbose: print(&#34;Mask band must be an integer or string&#34;)
            return
        mask = xdr.sel(band=mask_band).values != 0

    if mask_band is None:
        # find band number for attribute that includes &#39;mask&#39;
        mask_band = [i for i, s in enumerate(xdr.attrs[&#39;long_name&#39;]) if &#39;mask&#39; in s]
        if len(mask_band) == 0:
            if verbose: print(&#39;No mask band found in attributes. Proceeding without masking.&#39;)
        else:
            if len(mask_band) &gt; 1:
                if verbose: print(f&#34;Multiple mask bands found in attributes. Proceeding with mask band: {xdr.attrs[&#39;long_name&#39;][mask_band[0]]}&#34;)
            mask_band = mask_band[0] + 1
            if verbose: print(f&#34;Masking values with Nan where mask band {xdr.attrs[&#39;long_name&#39;][mask_band[0]]} is valid&#34;)
            mask = xdr.sel(band=mask_band).values != 0

    return mask</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="geodata_harvester.temporal.aggregate_temporal"><code class="name flex">
<span>def <span class="ident">aggregate_temporal</span></span>(<span>xdr, period='yearly', agg=['mean'], outfile='temporal_agg', buffer=None, fill_nan=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Make a data aggregation (mean, median, sum, etc) through time on an xarray.
Expects xarray coordinates to be x, y, time. Saves every aggregation for
every time period as its own tif file.</p>
<p>Example:
file_list = ['../data/mvp_daily_rain_silo/daily_rain_2017_cropped.tif',
'../data/mvp_daily_rain_silo/daily_rain_2018_cropped.tif']</p>
<p>xdr = combine_rasters_temporal(file_list, channel_name='band',attribute_name='long_name')</p>
<p>outfname_list, agg_list = aggregate_temporal(
xdr,period=100,agg=['mean','sum'],outfile='temporal_agg')</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>xdr</code></strong> :&ensp;<code>xarray object</code> of <code>x,y,time</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>period</code></strong> :&ensp;<code>string</code> or <code>int. Time period to perform aggregation,</code></dt>
<dd>'yearly', 'monthly', or number of periods to aggregate over.</dd>
<dt><strong><code>agg</code></strong> :&ensp;<code>list</code> of <code>strings. Choice</code> of <code>aggregation methods to apply of</code></dt>
<dd>['mean','median','sum','perc95','perc5']</dd>
<dt>outfile : string. Prefix of output file name.</dt>
<dt>buffer: integer time period in same units as period to buffer into the future.</dt>
<dt><strong><code>fill_nan</code></strong> :&ensp;<code>boolean. If True (Default), will automatically try to find the value for missing data </code></dt>
<dd>from header and fills with nan before aggregating. If False, will not fill nan.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>outfname_list</code></strong> :&ensp;<code>list</code> of <code>strings</code> of <code>output file names</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>agg_list</code></strong> :&ensp;<code>list</code> of <code>strings</code> of <code>aggregation methods</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def aggregate_temporal(xdr,
    period=&#34;yearly&#34;, agg=[&#34;mean&#34;], outfile=&#34;temporal_agg&#34;, buffer = None, fill_nan = True):
    &#34;&#34;&#34;
    Make a data aggregation (mean, median, sum, etc) through time on an xarray.
    Expects xarray coordinates to be x, y, time. Saves every aggregation for
    every time period as its own tif file.

    Example:
    file_list = [&#39;../data/mvp_daily_rain_silo/daily_rain_2017_cropped.tif&#39;,
         &#39;../data/mvp_daily_rain_silo/daily_rain_2018_cropped.tif&#39;]

    xdr = combine_rasters_temporal(file_list, channel_name=&#39;band&#39;,attribute_name=&#39;long_name&#39;)

    outfname_list, agg_list = aggregate_temporal(
        xdr,period=100,agg=[&#39;mean&#39;,&#39;sum&#39;],outfile=&#39;temporal_agg&#39;)

    Parameters
    ----------
    xdr : xarray object of x,y,time
    period : string or int. Time period to perform aggregation,
        &#39;yearly&#39;, &#39;monthly&#39;, or number of periods to aggregate over.
    agg: list of strings. Choice of aggregation methods to apply of
        [&#39;mean&#39;,&#39;median&#39;,&#39;sum&#39;,&#39;perc95&#39;,&#39;perc5&#39;]
    outfile : string. Prefix of output file name.
    buffer: integer time period in same units as period to buffer into the future.
    fill_nan: boolean. If True (Default), will automatically try to find the value for missing data 
        from header and fills with nan before aggregating. If False, will not fill nan.

    Returns
    -------
    outfname_list : list of strings of output file names
    agg_list : list of strings of aggregation methods

    &#34;&#34;&#34;

    if fill_nan:
        # Define the possible attribute names for fill values
        nodata_names = [&#34;_FillValue&#34;, &#34;missing_value&#34;, &#34;nodata&#34;, &#34;nodatavalue&#34;]
        nodata_name_found = False
        for nodata_name in nodata_names:
            if nodata_name in xdr.attrs:
                xdr = xdr.where(xdr != xdr.attrs[nodata_name], np.nan)
                nodata_name_found = True
                break
        # Check for case-insensitive nodata names
        if not nodata_name_found:
            for key, value in xdr.attrs.items():
                if key.lower() in [attr.lower() for attr in nodata_names]:
                    xdr = xdr.where(xdr != value, np.nan)
                    nodata_name_found = True
                    break


    # Check the aggregation methods are okay
    agg_types = [&#34;mean&#34;, &#34;median&#34;, &#34;sum&#34;, &#34;perc95&#34;, &#34;perc5&#34;, &#34;max&#34;, &#34;min&#34;]
    aggcheck = [a for a in agg if a in agg_types]
    if aggcheck is None:
        raise ValueError(&#34;Invalid Aggregation type. Expected any of: %s&#34; % agg_types)
    #else:
        #print(&#34;Finding&#34;, aggcheck, &#34; out of possible&#34;, agg_types)
        #print(&#34;for&#34;, period, &#34; period.&#34;)

    # Group by the appropriate time period
    if period == &#34;yearly&#34;:
        xdr_groups = xdr.groupby(&#34;time.year&#34;)

        if buffer != None:
            xx = xdr_groups.apply(lambda x: x.isel(time=slice(0,buffer)))
            xdr_groups = xx.groupby(&#34;time.year&#34;)

    elif period == &#34;monthly&#34;:
        xdr_groups = xdr.groupby(&#34;time.month&#34;)

        if buffer != None:
            xx = xdr_groups.apply(lambda x: x.isel(time=slice(0,buffer)))
            xdr_groups = xx.groupby(&#34;time.month&#34;)

    elif type(period) == int:
        time_start = xdr.time.values[0].astype(&#39;datetime64[s]&#39;).tolist()
        time_end = xdr.time.values[-1].astype(&#39;datetime64[s]&#39;).tolist()
        bins = (time_end - time_start).days // period
        #bins = int(np.floor(len(xdr) / period)) # this only works if len(xdr) is in days
        if bins == 0:
            # If the period is smaller than the time step, use the time step as the period
            bins = 1
        xdr_groups = xdr.groupby_bins(&#34;time&#34;, bins)

        if buffer != None:
            xx = xdr_groups.apply(lambda x: x.isel(time=slice(0,buffer)))
            xdr_groups = xx.groupby_bins(&#34;time&#34;, period)


    else:
        raise ValueError(
            &#34;Invalid temporal period. Expected any of: &#39;yearly&#39;, &#39;monthly&#39;, or an integer period&#34;
        )

    aggdict = {}
    for agg_type in aggcheck:
        if agg_type == &#34;mean&#34;:
            aggdict[&#34;mean&#34;] = xdr_groups.mean()
        elif agg_type == &#34;median&#34;:
            aggdict[&#34;median&#34;] = xdr_groups.median()
        elif agg_type == &#34;sum&#34;:
            aggdict[&#34;sum&#34;] = xdr_groups.sum()
        elif agg_type == &#34;perc95&#34;:
            aggdict[&#34;perc95&#34;] = xdr_groups.quantile(q=0.95)
        elif agg_type == &#34;perc5&#34;:
            aggdict[&#34;perc5&#34;] = xdr_groups.quantile(q=0.05)
        elif agg_type == &#34;max&#34;:
            aggdict[&#34;max&#34;] = xdr_groups.max()
        elif agg_type == &#34;min&#34;:
            aggdict[&#34;min&#34;] = xdr_groups.min()


    # Keep track of the names of all files produced
    outfname_list = []
    agg_list = []

    # For all the different aggregation methods
    for a in aggcheck:
        # For each period of time in each of the groups, save it out!
        for p in aggdict[a]:

            # Each temporal grouping results in different group labels
            if period == &#34;yearly&#34;:
                label = str(p[&#34;year&#34;].values)
            elif period == &#34;monthly&#34;:
                label = str(p[&#34;month&#34;].values).zfill(2)
            elif type(period) == int:
                label = str(p[&#34;time_bins&#34;].values)[1:11]

            p.rio.to_raster(outfile + &#34;_&#34; + a + &#34;_&#34; + label + &#34;.tif&#34;)
            outfname_list.append(outfile + &#34;_&#34; + a + &#34;_&#34; + label + &#34;.tif&#34;)
            agg_list.append(a)

            print(a, &#34;of&#34;, label, &#34;saved in:&#34;, outfile + &#34;_&#34; + a + &#34;_&#34; + label + &#34;.tif&#34;)

    return outfname_list, agg_list</code></pre>
</details>
</dd>
<dt id="geodata_harvester.temporal.combine_rasters_temporal"><code class="name flex">
<span>def <span class="ident">combine_rasters_temporal</span></span>(<span>file_list, channel_name='band', attribute_name='long_name')</span>
</code></dt>
<dd>
<div class="desc"><p>Combines multiple tif files into single xarray object.
Assumes additional channels contain sequential time step data.
If multiple files in file_list, files must be in temporal order and same data type.
Also assumes files are of the same shape (x,y,t).</p>
<p>Example:
file_list = ['../data/mvp_daily_rain_silo/daily_rain_2017_cropped.tif',
'../data/mvp_daily_rain_silo/daily_rain_2018_cropped.tif']</p>
<p>xdr = combine_rasters_temporal(file_list, channel_name='band',attribute_name='long_name')</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt>file_list : str or list of filename strings in date order to concatenate.</dt>
<dt>Expected to be of the form "x,y" or "x,y,z1"</dt>
<dt><strong><code>channel_name</code></strong> :&ensp;<code>string</code> of <code>coordinate dimension to concatentate (band, time,</code></dt>
<dd>etc). Check options with rioxarray.open_rasterio('filename').coords</dd>
<dt><strong><code>attribute_name</code></strong> :&ensp;<code>string name</code> of <code>rioxarray attribute holding a time/date</code></dt>
<dd>label. Check with rioxarray.open_rasterio('filename').attrs</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>xdr : xarray object of x,y,time, with approriate metadata.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def combine_rasters_temporal(
    file_list, channel_name=&#34;band&#34;, attribute_name=&#34;long_name&#34;
):
    &#34;&#34;&#34;
    Combines multiple tif files into single xarray object. 
    Assumes additional channels contain sequential time step data. 
    If multiple files in file_list, files must be in temporal order and same data type.
    Also assumes files are of the same shape (x,y,t).

    Example:
    file_list = [&#39;../data/mvp_daily_rain_silo/daily_rain_2017_cropped.tif&#39;,
             &#39;../data/mvp_daily_rain_silo/daily_rain_2018_cropped.tif&#39;]

    xdr = combine_rasters_temporal(file_list, channel_name=&#39;band&#39;,attribute_name=&#39;long_name&#39;)

    Parameters
    ----------
    file_list : str or list of filename strings in date order to concatenate.
        Expected to be of the form &#34;x,y&#34; or &#34;x,y,z1&#34;
    channel_name : string of coordinate dimension to concatentate (band, time,
        etc). Check options with rioxarray.open_rasterio(&#39;filename&#39;).coords
    attribute_name : string name of rioxarray attribute holding a time/date
        label. Check with rioxarray.open_rasterio(&#39;filename&#39;).attrs

    Returns
    -------
    xdr : xarray object of x,y,time, with approriate metadata.

    &#34;&#34;&#34;
    #print(&#34;Concatenating&#34;, channel_name, &#34;and&#34;, attribute_name, &#34;over&#34;, file_list)
    # file_list = glob(os.path.join(data_dir, &#39;*.tif&#39;))

    if type(file_list) == str:
        file_list = [file_list]

    # Append all data/channels, collect metadata lists
    array_list = []
    attrs = ()
    first = True
    for x in file_list:
        xds = rioxarray.open_rasterio(x)

        if channel_name not in xds.coords:
            raise ValueError(
                channel_name + &#34; not a channel in the raster &#34; + x + &#34; Options are&#34;,
                [t for t in xds.coords],
            )
            return None

        if attribute_name not in xds.attrs:
            raise ValueError(
                attribute_name
                + &#34; not an attribute in the raster &#34;
                + x
                + &#34; Options are&#34;,
                [t for t in xds.attrs],
            )
            return None

        array_list.append(xds)
        #print(&#34;attrs&#34;, xds.attrs[attribute_name])
        try:
            attrs = attrs + xds.attrs[attribute_name]
        except:
            attrs = attrs + (xds.attrs[attribute_name],)
        if first == True:
            coords = xds[channel_name].values

            first = False
        else:
            coords = np.append(coords, xds[channel_name].values + coords[-1])

    xdr = xr.concat(array_list, channel_name)
    # print(agg,coords,attrs)
    # xdr = xdr.assign_attrs({attr: attrs})
    xdr = xdr.assign_coords({channel_name: np.array(pd.to_datetime(attrs))})
    xdr = xdr.rename({channel_name: &#34;time&#34;})
    del xdr.attrs[attribute_name]

    return xdr</code></pre>
</details>
</dd>
<dt id="geodata_harvester.temporal.get_date_after_last_underscore"><code class="name flex">
<span>def <span class="ident">get_date_after_last_underscore</span></span>(<span>file_list)</span>
</code></dt>
<dd>
<div class="desc"><p>Extract the date from the file name after the last underscore.</p>
<h2 id="parameters">Parameters</h2>
<p>file_list : list of filename strings in date order to concatenate.</p>
<h2 id="returns">Returns</h2>
<p>result : list of dates in date order to concatenate.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_date_after_last_underscore(file_list):
    &#34;&#34;&#34;
    Extract the date from the file name after the last underscore.

    Parameters
    ----------
    file_list : list of filename strings in date order to concatenate.

    Returns
    -------
    result : list of dates in date order to concatenate.
    &#34;&#34;&#34;
    result = []

    for filename in file_list:
        split_string = filename.rsplit(&#39;_&#39;, 1)  # Split the string from the right side, keeping only the last part

        # Check if the string was split
        if len(split_string) &gt; 1:
            last_part = split_string[-1]  # Get the part after the last &#34;_&#34;
        else:
            last_part = filename  # If the string didn&#39;t have any &#34;_&#34;, return the original string

        # Remove the file format ending
        last_part = last_part.rsplit(&#39;.&#39;, 1)[0]

        # test if the last part is a date
        try:
            datetime.datetime.strptime(last_part, &#39;%Y-%m-%d&#39;)
        except ValueError:
            print(&#34;The last part of the filename is not a date: &#34;, last_part)
            raise ValueError

        result.append(last_part)

    return result</code></pre>
</details>
</dd>
<dt id="geodata_harvester.temporal.get_mask_array"><code class="name flex">
<span>def <span class="ident">get_mask_array</span></span>(<span>xdr, mask_band=None, verbose=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Return mask of the data, e.g. for cloud-cover.
The mask values will be set to True if the mask band is not 0, and False otherwise.
If no mask band is provided, a mask band will be searched for in the xarray attribute metadata.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>xdr</code></strong> :&ensp;<code>xarray</code></dt>
<dd>xarray dataset to mask</dd>
<dt><strong><code>mask_band</code></strong> :&ensp;<code>str</code> or <code>int</code>, optional</dt>
<dd>Name or index of the band to use as a mask.
If not provided, a mask abd will be searched for in the xarray attribute metadata.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>mask</code></strong> :&ensp;<code>array, bool</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_mask_array(xdr, mask_band = None, verbose = True):
    &#34;&#34;&#34;
    Return mask of the data, e.g. for cloud-cover.
    The mask values will be set to True if the mask band is not 0, and False otherwise.
    If no mask band is provided, a mask band will be searched for in the xarray attribute metadata.

    Parameters
    ----------
    xdr : xarray
        xarray dataset to mask
    mask_band : str or int, optional   
        Name or index of the band to use as a mask. 
        If not provided, a mask abd will be searched for in the xarray attribute metadata.

    Returns
    -------
    mask: array, bool
    &#34;&#34;&#34;
    if mask_band is not None:
        if isinstance(mask_band, int):
            if verbose: print(f&#34;Masking values with Nan where mask band {mask_band} is not 0&#34;)
        elif isinstance(mask_band, str):
            if verbose: print(f&#34;Masking values with Nan where mask band {mask_band} is not 0&#34;)
            mask_band = [i for i, s in enumerate(xdr.attrs[&#39;long_name&#39;]) if s == mask_band]
            mask_band = mask_band[0] + 1
        else:
            if verbose: print(&#34;Mask band must be an integer or string&#34;)
            return
        mask = xdr.sel(band=mask_band).values != 0

    if mask_band is None:
        # find band number for attribute that includes &#39;mask&#39;
        mask_band = [i for i, s in enumerate(xdr.attrs[&#39;long_name&#39;]) if &#39;mask&#39; in s]
        if len(mask_band) == 0:
            if verbose: print(&#39;No mask band found in attributes. Proceeding without masking.&#39;)
        else:
            if len(mask_band) &gt; 1:
                if verbose: print(f&#34;Multiple mask bands found in attributes. Proceeding with mask band: {xdr.attrs[&#39;long_name&#39;][mask_band[0]]}&#34;)
            mask_band = mask_band[0] + 1
            if verbose: print(f&#34;Masking values with Nan where mask band {xdr.attrs[&#39;long_name&#39;][mask_band[0]]} is valid&#34;)
            mask = xdr.sel(band=mask_band).values != 0

    return mask</code></pre>
</details>
</dd>
<dt id="geodata_harvester.temporal.multiband_raster_to_xarray"><code class="name flex">
<span>def <span class="ident">multiband_raster_to_xarray</span></span>(<span>file_list, date_list=None, mask_bandname=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Converts a stack of multiband raster with different dates to an xarray object.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt>file_list : list of filename strings in date order to concatenate.</dt>
<dt><strong><code>date_list</code></strong> :&ensp;<code>list</code> of <code>dates in date order to concatenate. </code></dt>
<dd>If None provided, the dates will be extracted from the file names.
This assumes that the date is given at the end of the file name after an underscore.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def multiband_raster_to_xarray(file_list, date_list = None, mask_bandname = None):
    &#34;&#34;&#34;
    Converts a stack of multiband raster with different dates to an xarray object.
    
    Parameters
    ----------
    file_list : list of filename strings in date order to concatenate.
    date_list : list of dates in date order to concatenate. 
        If None provided, the dates will be extracted from the file names.
        This assumes that the date is given at the end of the file name after an underscore.
    &#34;&#34;&#34;
    # Extract the dates from the file names if no date list is provided
    if date_list is None:
        date_list = get_date_after_last_underscore(file_list)

    # Check if the lists have the same length
    assert len(file_list) == len(date_list), &#34;File list and date list must have the same length.&#34;
    
    # Create an empty list to store the DataArrays
    data_arrays = []

    for file, date in zip(file_list, date_list):
        # Read the raster file using rioxarray
        xds = rioxarray.open_rasterio(file)

        # Assign the time coordinate
        xds = xds.assign_coords({&#34;time&#34;: pd.to_datetime(date)})
        xds = xds.expand_dims(&#34;time&#34;)

        # Append the DataArray to the list
        data_arrays.append(xds)

    # Concatenate the DataArrays along the time dimension
    stacked_data = xr.concat(data_arrays, dim=&#34;time&#34;)

    return stacked_data</code></pre>
</details>
</dd>
<dt id="geodata_harvester.temporal.temporal_crop"><code class="name flex">
<span>def <span class="ident">temporal_crop</span></span>(<span>xdr, start_time, end_time)</span>
</code></dt>
<dd>
<div class="desc"><p>Cuts an xarray object by start and end times.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>xdr</code></strong> :&ensp;<code>xarray object</code> of <code>x,y,time</code></dt>
<dd>&nbsp;</dd>
</dl>
<p>start_time : string time in 'yyyy-mm-dd' format.
end_time : string time in 'yyyy-mm-dd' format.</p>
<h2 id="returns">Returns</h2>
<p>xdr_crop : xarray object of x,y,time, with approriate metadata.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def temporal_crop(xdr, start_time, end_time):
    &#34;&#34;&#34;
    Cuts an xarray object by start and end times.

    Parameters
    ----------
    xdr : xarray object of x,y,time
    start_time : string time in &#39;yyyy-mm-dd&#39; format.
    end_time : string time in &#39;yyyy-mm-dd&#39; format.

    Returns
    -------
    xdr_crop : xarray object of x,y,time, with approriate metadata.
    &#34;&#34;&#34;

    xdr_crop = xdr.sel(time=slice(start_time, end_time))

    return(xdr_crop)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="geodata_harvester" href="index.html">geodata_harvester</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="geodata_harvester.temporal.aggregate_temporal" href="#geodata_harvester.temporal.aggregate_temporal">aggregate_temporal</a></code></li>
<li><code><a title="geodata_harvester.temporal.combine_rasters_temporal" href="#geodata_harvester.temporal.combine_rasters_temporal">combine_rasters_temporal</a></code></li>
<li><code><a title="geodata_harvester.temporal.get_date_after_last_underscore" href="#geodata_harvester.temporal.get_date_after_last_underscore">get_date_after_last_underscore</a></code></li>
<li><code><a title="geodata_harvester.temporal.get_mask_array" href="#geodata_harvester.temporal.get_mask_array">get_mask_array</a></code></li>
<li><code><a title="geodata_harvester.temporal.multiband_raster_to_xarray" href="#geodata_harvester.temporal.multiband_raster_to_xarray">multiband_raster_to_xarray</a></code></li>
<li><code><a title="geodata_harvester.temporal.temporal_crop" href="#geodata_harvester.temporal.temporal_crop">temporal_crop</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>